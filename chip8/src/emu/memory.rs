#[derive(Debug)]
pub struct Memory {
    pub data: [u8; 4096],
}

impl Memory {
    pub fn new() -> Self {
        Self { data: [0; 4096] }
    }
    pub fn print_memory(&self) {
        for (i, byte) in self.data.iter().enumerate() {
            if i % 16 == 0 {
                println!("\n{:04X}: ", i);
            }
            print!("{:02X} ", byte);
        }
        println!();
    }
}

/// # Chip8 FONT encoding
/// 16 chars are encoded from 00 - 4F
/// ## Examples
/// 0 = 0xF0 0x90 0x90 0x90 0xF0
/// 0xF = 1 1 1 1 =      1 1 1 1
/// 0x9 = 1 0 0 1 =      1     1
/// 0x9 = 1 0 0 1 =      1     1
/// 0x9 = 1 0 0 1 =      1     1
/// 0xF = 1 1 1 1 =      1 1 1 1
///
/// 1 = 0x20 0x60 0x20 0x20 0x70
/// 0x2 = 0 0 1 0 =          1
/// 0x6 = 0 1 1 0 =         11
/// 0x2 = 0 0 1 0 =          1
/// 0x2 = 0 0 1 0 =          1
/// 0x7 = 0 1 1 1 =         111
///
/// 2 = 0xF0 0x10 0xF0 0x80 0xF0
/// 0xF = 1 1 1 1 =       1 1 1 1
/// 0x1 = 0 0 0 1 =             1
/// 0xF = 1 1 1 1 =       1 1 1 1
/// 0x8 = 1 0 0 0 =       1
/// 0xF = 1 1 1 1 =       1 1 1 1
///
/// ... and so on.
pub const FONTS: [u8; 80] = [
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80, // F
];
